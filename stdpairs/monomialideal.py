r"""
MonomialIdeal

This module provides the base class :class:`MonomialIdeal` and a method :method:`prime_ideal()` in StdPairs.

AUTHORS:

- Byeongsu Yu (2021-02-25): initial version.

"""
#*****************************************************************************
#       Copyright (C) 2021 Byeongsu Yu <byeongsu.yu@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; version 3 of
#  the License. 
#                  http://www.gnu.org/licenses/
#*****************************************************************************
import numpy as np
from numpy import linalg as LA
import json
from pathlib import Path
from sage.all import ZZ
from sage.all import matrix
from sage.all import cartesian_product
from sage.combinat.combination import Combinations
from sage.misc.persist import save as sobj_save

from . import affinemonoid 
from . import properpair 
from . import _stdpairs
from . import _zsolve_interface
from . import _string_interface

class MonomialIdeal:
    r"""
    A class representing a monomial ideal of the given nonzero affine monoid ``ambient_monoid`` generated by a set of elements ``genset`` as a matrix form.

    INPUT:

    - ``genset`` -- A ``NumPy.ndarray`` object with 2-dimensional shape and integer elements or a ``sage.matrix.matrix_integer_dense`` object. All columns in ``genset`` must lie in ``ambient_monoid``.
    - ``ambient_monoid`` -- An ``AffineMonoid`` object. 

    OUTPUT:

    - A ``MonomialIdeal`` object representing a monomial ideal of an affine semigroup whose generating set is ``genset``.

    EXAMPLE:

    ::

        sage: from stdpairs import AffineMonoid, MonomialIdeal
        sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
        sage: import numpy
        sage: #Using ``NumPy``
        sage: M = numpy.array([[4,6],[4,6]])
        sage: I = MonomialIdeal(M,Q)
        sage: I                                                                         
        An ideal whose generating set is 
        [[4]
         [4]]
        
    ::

        sage: from stdpairs import AffineMonoid, MonomialIdeal
        sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
        sage: #Using ``sage.matrix.matrix_integer_dense``
        sage: M = matrix(ZZ,[[4,6],[4,6]])
        sage: I = MonomialIdeal(M,Q)
        sage: I                                                                         
        An ideal whose generating set is 
        [[4]
         [4]]


    TESTS::
            
        sage: from stdpairs import AffineMonoid, MonomialIdeal
        sage: A = matrix(ZZ,[[0,1,1,0],[0,0,1,1],[1,1,1,1]])
        sage: Q = AffineMonoid(A)
        sage: I = MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]]),Q)
        sage: I.standard_cover().keys()
        dict_keys([(0, 3)])
        sage: sorted(I.standard_cover()[(0,3)],key=str)
        [([[0], [0], [0]]^T,[[0, 0], [0, 1], [1, 1]]),
         ([[1], [0], [1]]^T,[[0, 0], [0, 1], [1, 1]]),
         ([[1], [1], [1]]^T,[[0, 0], [0, 1], [1, 1]])]
        sage: I.irreducible_decomposition()
        [An ideal whose generating set is 
         [[2 2 2]
          [0 1 2]
          [2 2 2]]]
        sage: for face, prime_id in I.associated_primes().items():
        ....:     if I.multiplicity(face) != I.multiplicity(prime_id):
        ....:         raise SyntaxError("[Error]: multiplicity() method does not work well. Report it to the developer.")
        sage: if (I.is_prime() != False) or (I.is_radical() != False) or (I.is_primary() != True):
        ....:     raise SyntaxError("[Error]: the boolean methods does not work well. Report it to the developer.")
        
    """
    def __init__(self, genset, ambient_monoid):
        type_mat = type(matrix(ZZ,0))
        if isinstance(genset, type_mat):
            genset = np.array(genset).astype('int64')
        del type_mat
        # Check types of the input
        if not isinstance(genset,np.ndarray):
            raise ValueError("[Error]: 1st argument is not numpy.ndarray type or sage.matrix type")
        if not isinstance(ambient_monoid, affinemonoid.AffineMonoid):
            raise ValueError("[Error]: 2nd argument is not an affine monoid")
        
        #Check that each generators are inside of an ambient monoid.
        if (genset.size == 0):
            self.__gens=np.array([], dtype='int64')[np.newaxis].T
            self.__ambient_monoid=ambient_monoid
            self.__is_principal_bool =False
            self.__is_empty_ideal_bool=True
        else:
            if len(genset.shape)!=2:
                raise ValueError("[Error]: the generating set is 1D-array; you need 2D array whose column corresponds to a generator.")
            self.__is_empty_ideal_bool=False
            for column in genset.T:
                temp= ambient_monoid.is_element(column[np.newaxis].T)
                if not (temp.dimensions()[0]):
                    #If there is no solution
                    raise ValueError("[Error]: A generator ["+_string_interface._np2d_to_string(column[np.newaxis].T)+"]^t in the given generating matrix"+ _string_interface._np2d_to_string(genset)+"is not in the ambient monoid.")
                del temp
            #Initialize attributes.
            self.__ambient_monoid = ambient_monoid
            self.__gens = _zsolve_interface._mingens(self.__ambient_monoid.gens(),genset)
            if self.__gens.shape[1] == 1:
                self.__is_principal_bool = True
            else:
                self.__is_principal_bool= False
        # Now we set __hashstring for ideal.
        self.__hashstring = _string_interface._np2d_to_string(self.__gens)+'&'+_string_interface._np2d_to_string(self.__ambient_monoid.gens())
        # Declare attribute for future works, after standard cover is calculated.
        self.__is_std_cover_calculated = False;
        self.__is_radical_calculated = False;
        self.__is_radical_ideal_calculated = False;
        self.__is_primary_calculated=False;
        self.__is_irreducible_calculated=False;
        self.__is_prime_calculated=False;
        self.__is_overlap_calculated=False;
        self.__is_max_overlap_calculated=False;
        self.__is_ass_prime_calculated = False;
        self.__is_irr_decom_prime_calculated = False;
        self.__is_radical_bool = False;
        self.__is_primary_bool = False;
        self.__is_prime_bool = False;
        self.__is_irreducible_bool = False;
    def ambient_monoid(self):
        r"""
        returns the ambient monoid of ``self``.
    
        OUTPUT:

        - An ``AffineMonoid`` object.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[4,6],[4,6]]),Q)
            sage: I.ambient_monoid()
            An affine semigroup whose generating set is 
            [[1 2]
             [0 2]]

        """
        return self.__ambient_monoid
    def gens(self):
        r"""
        returns the *minimal* generating matrix of the given monomial ideal. Notes that the generating matrix which was input when the object created is not stored.
    
        OUTPUT:

        - A ``NumPy.ndarray`` object with 2-dimensional shape and integer elements

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[4,6],[4,6]]),Q)
            sage: I.gens()
            array([[4],
                   [4]])

        """
        return self.__gens
    def is_empty(self):
        r"""
        returns ``True`` iff it is an empty set as a monomial ideal.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[4,6],[4,6]]),Q)
            sage: I.is_empty()                                                              
            False
            sage: J=MonomialIdeal(matrix(ZZ,0),Q)                                         
            sage: J.is_empty()                                                              
            True
        """
        return self.__is_empty_ideal_bool
    def is_principal(self):
        r"""
        returns ``True`` iff it is a principal monomial ideal.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[4,6],[4,6]]),Q)
            sage: I.is_principal()
            True
        """
        return self.__is_principal_bool
    def standard_cover(self, verbose=True):
        r"""
        returns a dictionary whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid()`` and 
        whose values are ``list`` objects containing standard pairs of ``self`` sharing the same faces. See [MY2020]_ for the mathematical definition of standard pair. Depending on machines and the number of generators of ideals or affine monoid, this method takes a few minutes to a few hours.
        Notes that it does not show the status if the given monomial ideal is principal. 

        If ``verbose`` is ``False``, then the function let user knows its progress on computation by showing how many generators are computed.

        OUTPUT:

        - A ``dictionary`` object whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid`` and whose values are ``list`` objects consisting of ``ProperPair`` objects sharing the same face. 
        
        Below is an example for finding standard cover of a principal monomial ideal.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q = AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I = MonomialIdeal(matrix(ZZ,[[4,6],[4,6]]),Q)
            sage: I.standard_cover()
            {(0,): [([[0], [0]]^T,[[1], [0]]), ([[2], [2]]^T,[[1], [0]])]}
        
        Below is an example for finding standard cover of a non-principal monomial ideal when ``verbose=False``. 

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q = AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I = MonomialIdeal(matrix(ZZ,[[4,3],[4,2]]),Q) 
            sage: I.standard_cover(False)[(0,)]                                                        
            Calculate the standard cover of an ideal
            It takes a few minutes, depending on the system.
            Cover for 1  generator was calculated.  1  generators remaining. 
            Cover for 2  generators was calculated.  0  generators remaining. 
            [([[0], [0]]^T,[[1], [0]])]
            sage: I.standard_cover()[()]
            [([[2], [2]]^T,[[], []])]
            sage: sorted(I.standard_cover().keys(),key=str)
            [(), (0,)]

        Below is an example for comparing `standardPairs <https://faculty.math.illinois.edu/Macaulay2/doc/Macaulay2-1.15/share/doc/Macaulay2/Macaulay2Doc/html/_standard__Pairs.html>`_ function in `Macaulay2 <http://www.math.uiuc.edu/Macaulay2/>`_ and that of ``self.standard_cover()``

        EXAMPLE::
            
            sage: print("test MonomialIdeal.standard_cover() . . . .")
            test MonomialIdeal.standard_cover() . . . .
            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: import numpy as np
            sage: import ast
            sage: numvar = 3
            sage: numgen = 1
            sage: A = np.identity(numvar,dtype="int64")
            sage: B = np.random.randint(3, size=(numvar, numgen))
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(B,Q)
            sage: # Calculate it by Macaulay2
            sage: # Set a polynomial ring first.
            sage: temp=macaulay2.eval('R=ZZ[vars (0..'+str(numvar-1)+')]')
            sage: gens_ideal='I=monomialIdeal(';
            sage: for row in I.gens().T:
            ....:     eq='' 
            ....:     for idx in range(numvar): 
            ....:         eq=eq+'R_'+str(idx)+'^'+str(row[idx])+'*' 
            ....:     eq = eq[:-1] 
            ....:     gens_ideal=gens_ideal + eq+',' 
            sage: gens_ideal=gens_ideal[:-1] + ')'
            sage: temp=macaulay2.eval(gens_ideal)
            sage: temp=macaulay2.eval('L=standardPairs I')
            sage: result=list(macaulay2('T=apply(L, i -> {(exponents i_0)_0, apply(i_1, j -> index j)})')) 
            sage: for item in result: temp=item[1].sort();
            sage: faces = list(set([tuple(item[1]) for item in result])) 
            sage: faces = [ast.literal_eval(str(face)) for face in faces]
            sage: cover_from_mac2={}
            sage: for face in faces: 
            ....:     cover_from_mac2[face]=[] 
            ....:     for item in result: 
            ....:         if face == tuple(item[1]): 
            ....:             cover_from_mac2[face].append(ast.literal_eval(str(tuple(item[0]))))
            sage: # Calculate standard pairs by stdpairs package
            sage: cover_from_sage ={}
            sage: for face,list_of_pairs in I.standard_cover().items(): 
            ....:     cover_from_sage[face] = [tuple(pair.monomial().T.tolist()[0]) for pair in list_of_pairs]
            sage: # Check equality:
            sage: faces=list(cover_from_mac2.keys())+list(cover_from_sage.keys())
            sage: faces=list(set([str(item) for item in faces]))
            sage: faces=[ast.literal_eval(item) for item in faces]
            sage: for face in faces:
            ....:     if set([str(item) for item in cover_from_sage[face]]) != set([str(item) for item in cover_from_mac2[face]]):
            ....:         raise SyntaxError("Standard pairs from Macaulay2 are not equal to those from stdpairs package.")
            sage: print("pass")
            pass

            
        """
        if self.is_empty() == True:
            top_face=tuple(list(range((self.__ambient_monoid.gens()).shape[1])))
            zero_monomial = (self.__ambient_monoid.gens())[:,(1,)]*0
            self.__dict_standard_pairs= {top_face:[properpair.ProperPair(zero_monomial,top_face,self)]}
            self.__is_std_cover_calculated = True
            return self.__dict_standard_pairs
        if (self.__is_std_cover_calculated == False):
            temp_cover = _stdpairs._standard_pairs(self, verbose)
            self.__dict_standard_pairs={}
            for face, list_of_pairs in temp_cover.items():
                newlist = sorted(list_of_pairs, key=str, reverse=False)
                self.__dict_standard_pairs[face]=newlist
            self.__is_std_cover_calculated = True
        return self.__dict_standard_pairs
    def overlap_classes(self):
        r"""
        returns a dictionary whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid()`` and 
        whose values are ``list`` objects consisting of ``list`` objects containing standard pairs within the same overlap classes. 
        See [MY2020]_ for the mathematical definition of overlap classes of standard pairs.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A ``dictionary`` object whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid`` and whose values are ``list`` objects consisting of ``list`` objects representing an overlap class. This list consists of ``ProperPair`` objects in the same overlap classes.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[0,1,1,0],[0,0,1,1],[1,1,1,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]]),Q)
            sage: I.overlap_classes().keys()
            dict_keys([(0, 3)])
            sage: len(I.overlap_classes()[(0,3)])
            2
            sage: sorted(I.overlap_classes()[(0,3)][0],key=str)
            [([[0], [0], [0]]^T,[[0, 0], [0, 1], [1, 1]])]
            sage: sorted(I.overlap_classes()[(0,3)][1],key=str)
            [([[1], [0], [1]]^T,[[0, 0], [0, 1], [1, 1]]),
             ([[1], [1], [1]]^T,[[0, 0], [0, 1], [1, 1]])]
            sage: #Notes that two overlap classes are generated from three standard pairs.
            
        """
        if self.__is_overlap_calculated == True:
            return self.__dict_overlap_classes
        else:
            self.__dict_overlap_classes = _stdpairs._find_overlap_classes(self.standard_cover())
            self.__is_overlap_calculated = True
            return self.__dict_overlap_classes
    def is_irreducible(self):
        r"""
        returns ``True`` iff it is an irreducible monomial ideal. Notes that this method executes ``self.standard_cover()`` if it was not executed previously.

        EXAMPLE(Irreducible case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[0,1,1,0],[0,0,1,1],[1,1,1,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]]),Q)
            sage: I.is_irreducible()
            True
            sage: # After the first execution, it uses the pre-calculated result.
            sage: I.is_irreducible()
            True 

        EXAMPLE(Non-irreducible case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[5],[4]]),Q)
            sage: I.is_irreducible()
            False

        """
        if self.__is_irreducible_calculated == True:
            return self.__is_irreducible_bool
        else:
            max_overlaps = self.maximal_overlap_classes()
            if len(max_overlaps.keys()) == 1:
                for key, value in max_overlaps.items():
                    if len(value) == 1:
                        self.__is_irreducible_calculated = True
                        self.__is_irreducible_bool = True
                        return self.__is_irreducible_bool
            self.__is_irreducible_calculated = True
            self.__is_irreducible_bool = False
            return self.__is_irreducible_bool
    def is_prime(self):
        r"""
        returns ``True`` iff it is a prime monomial ideal. Notes that this method executes ``self.standard_cover()`` if it was not executed previously.
            
        EXAMPLE(Prime case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[1,1],[0,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[1],[0]]),Q)
            sage: I.is_prime()                                                              
            True
            sage: # After the first execution, it uses the pre-calculated result.
            sage: I.is_prime()
            True

        EXAMPLE(Non-prime case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[1,1],[0,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[1,2],[0,2]]),Q)
            sage: I.is_prime()
            False
            
        """
        if self.__is_prime_calculated:
            return self.__is_prime_bool
        else:
            if (self.is_radical() == False):
                self.__is_prime_bool = False;
                return self.__is_prime_bool
            if (self.is_primary() == False):
                self.__is_prime_bool = False;
                return self.__is_prime_bool
            unique_key=list(self.__dict_standard_pairs.keys())[0]
            if (len(self.__dict_standard_pairs[unique_key]) == 1):
                self.__is_prime_bool = True
            else:
                self.__is_prime_bool = False
            self.__is_prime_calculated = True
            return self.__is_prime_bool

    def is_primary(self):
        r"""
        returns ``True`` iff it is a primary monomial ideal. Notes that this method executes ``self.standard_cover()`` if it was not executed previously.

        EXAMPLE(Primary case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[1,1],[0,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[7],[0]]),Q)
            sage: I.is_primary()
            True
            sage: # After the first execution, it uses the pre-calculated result.
            sage: I.is_primary()
            True 

        EXAMPLE(Non-primary case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[5],[4]]),Q)
            sage: I.is_primary()
            False

        """
        if self.__is_primary_calculated:
            return self.__is_primary_bool
        else:
            if (self.__is_std_cover_calculated == False):
                self.standard_cover()
            if (len(self.__dict_standard_pairs) == 1):
                self.__is_primary_bool=True
            else:
                self.__is_primary_bool=False
            self.__is_primary_calculated=True
            return self.__is_primary_bool
    def is_radical(self):
        r"""
        returns ``True`` iff it is a radical monomial ideal. Notes that this method executes ``self.standard_cover()`` if it was not executed previously.


        EXAMPLE(Radical case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: I.is_radical()
            True
            sage: # After the first execution, it uses the pre-calculated result.
            sage: I.is_radical()
            True 

        EXAMPLE(Non-radical case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[6,5],[2,2]]),Q)
            sage: I.is_radical()
            False
            
        """
        if self.__is_radical_calculated:
            return self.__is_radical_bool
        else:
            if (self.__is_std_cover_calculated == False):
                self.standard_cover()
            is_radical = True;
            for face, pair_list in self.__dict_standard_pairs.items():
                for pair in pair_list:
                    if np.any(pair.monomial()) == True:
                        is_radical = False
            self.__is_radical_bool = is_radical
            self.__is_radical_calculated= True;
            return self.__is_radical_bool
    def is_element(self, monomial):
        r"""
        Suppose :math:`A` is the generating matrix of the ambient monoid of the given monomial ideal and :math:`b` is a vector given by the input ``monomial``. Then
        this function returns a ``dictionary`` object whose keys are integers denoting indices, say :math:`i` of column of ``self.gens()``, and whose values are ``sage.matrix.matrix_integer_dense`` objects whose row :math:`u` satisfies :math:`A \cdot u^{t}=b-c_{i}`.
        In other words, if the input is an element of the given monomial ideal, this method returns non-empty dictionary, whose value is a matrix such that rows show how to generated
        the input using the generators of the affine monoid. Otherwise, if the input is not the element of the given affine monoid, this method returns the empty dictionary.

        INPUT:

        - ``monomial`` -- A ``NumPy.ndarray`` object with 2-dimensional shape and integer elements or a ``sage.matrix.matrix_integer_dense`` object. This must be a vector; i.e. have one column.

        OUTPUT:

        - A ``dictionary`` type object whose keys are integers denoting index of columns of ``self.gens()`` and whose values are ``sage.matrix.matrix_integer_dense`` object whose row :math:`u` is the solution of the equation :math:`A \cdot u^{t}=b-c_{i}`, for given key :math:`i` with a column vector :math:`c_{i}` of ``self.gens()``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3,7],[2,0]]),Q)
            sage: I.is_element(matrix(ZZ,[[9],[2]]))                                      
            {0: [6 0], 1: [0 1]}
            sage: # In other words, (9,2)^{t} = (3,2)^{t}+6*(1,0)^{t}
            sage: # and (9,2)^{t}= (7,0)^{t}+1*(2,2)^{t}
        """
        if self.is_empty():
            return matrix(ZZ,0)
        # Check whether the monomial has the same dimension with an affine integral spaces of ambient monoid.
        if isinstance(monomial,type(matrix(ZZ,0))):
            if monomial == matrix(ZZ,0):
                monomial = 0*(self.__gens[:,0][np.newaxis]).T
            else:
                monomial = np.array(monomial).astype('int64')
        if monomial.shape != ((self.__gens[:,0][np.newaxis]).T).shape:
            raise ValueError("[Error]: The dimension of a monomial not matched with the dimension of the ambient monoid.")
        result={}
        for count, column in enumerate(self.__gens.T):
            idx=self.__ambient_monoid.is_element(monomial-column[np.newaxis].T)
            if idx.nrows(): #If index is nonempty, i.e., the given monomial is a generator + some element in the monoid,
                result[count]=idx
        return result
    def is_standard_monomial(self,monomial):
        r"""
        returns ``True`` iff it is a *standard monomial*, i.e., a monomial outside of the ideal.


        EXAMPLE(Radical case)::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: I.is_standard_monomial(matrix(ZZ,[[1],[1]]))
            True
            sage: #(1,1)^t is not a memeber of ideal.

        """
        type_mat = type(matrix(ZZ,0))
        if isinstance(monomial, type_mat):
            monomial = np.array(monomial).astype('int64')
        del type_mat
        if self.is_empty(): #If the ideal is a zero ideal
            return True
        if self.__gens.shape[1]==0: #If the ideal is not a zero ideal
            return True
        if self.is_element(monomial):            
            return False
        else:
            return True
    
    def maximal_overlap_classes(self):
        r"""
        returns a dictionary whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid()`` and 
        whose values are ``list`` objects consisting of ``list`` objects containing standard pairs within the same overlap classes, whchs are maximal with respect to divisibility. 
        Here, divisibility means that for given two overlap classes :math:`[a,F],[b,G]`, :math:`[a,F]<[b,G]` if there exists :math:`c` in the affine monoid
        such that :math:`a+c+\mathbb{N}F \subseteq b+\mathbb{N}G`.
        See [MY2020]_ for the mathematical definition of overlap classes of standard pairs.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A ``dictionary`` object whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid`` and whose values are ``list`` objects consisting of ``list`` objects representing an overlap class. This list consists of ``ProperPair`` objects in the same maximal overlap classes.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3,4],[0,2]]),Q)
            sage: I.overlap_classes()
            {(): [[([[2], [0]]^T,[[], []])]],
             (1,): [[([[0], [0]]^T,[[2], [2]])], [([[1], [0]]^T,[[2], [2]])]]}
            sage: I.maximal_overlap_classes()                                             
            {(): [[([[2], [0]]^T,[[], []])]], (1,): [[([[1], [0]]^T,[[2], [2]])]]}
            
        """
        if self.__is_max_overlap_calculated:
            return self.__dict_max_overlap_classes
        else:
            classes = self.overlap_classes()
            dict_classes = {}
            for key,value in classes.items():
                temp_list = [];
                for pair_list in value:
                # Notes that we only need to check the maximal w.r.t. divisibility 
                # over one standard pair; then the other one should be a maximal, too.
                    if pair_list[0].is_maximal():
                        temp_list.append(pair_list)
                dict_classes[key] = temp_list
            self.__dict_max_overlap_classes = dict_classes
            self.__is_max_overlap_calculated = True
            
            return self.__dict_max_overlap_classes
    def associated_primes(self):
        r"""
        returns a dictionary whose keys are tuples representing faces of ``self.ambient_monoid`` and 
        whose values are ``MonomialIdeal`` objects which are prime ideals corresponding to the faces in their keys.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A ``dictionary`` object whose keys are ``tuple`` objects representing faces of ``self.ambient_monoid`` and whose values are ``MonomialIdeal`` objects representing prime monomial ideals corresponding to the faces in their keys.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q = AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I = MonomialIdeal(matrix(ZZ,[[3],[0]]),Q)
            sage: I.associated_primes()                                                                                                                     
            {(1,): An ideal whose generating set is 
             [[1]
              [0]]}

        """    
        if self.__is_ass_prime_calculated == True:
            return self.__dict_associated_prime_ideals
        if not self.__is_max_overlap_calculated:
            self.maximal_overlap_classes()
        self.__dict_associated_prime_ideals = {}
        list_associated_faces = list(self.__dict_max_overlap_classes.keys())
        for face in list_associated_faces:
            self.__dict_associated_prime_ideals[face]=prime_ideal(face,self.__ambient_monoid)
        self.__is_ass_prime_calculated = True
        return self.__dict_associated_prime_ideals
    def multiplicity(self, an_ideal_or_face):
        r"""
        Given an associated prime ideal or face (as a ``tuple`` object) corresponding to an associated prime ideal,
        returns the multiplicity of the prime ideal over the given monomial ideal ``self``.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A non-negative integer denoting the multiplicity of the given associated prime over the monomial ideal ``self``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q = AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I = MonomialIdeal(matrix(ZZ,[[3],[0]]),Q)
            sage: I.associated_primes()                                                                                                                     
            {(1,): An ideal whose generating set is 
             [[1]
              [0]]}
            sage: # Check multiplicity using a face as an argument.
            sage: I.multiplicity((1,))                                                                                                                     
            3
            sage: # Check multiplicity using the prime ideal as an argument.
            sage: I.multiplicity(I.associated_primes()[(1,)]) 
            3

        """
        if isinstance(an_ideal_or_face, MonomialIdeal):
            for face, prime_ideal in (self.associated_primes()).items():
                if prime_ideal == an_ideal_or_face:
                    ovl_classes = self.overlap_classes()
                    return len(ovl_classes[face])
            raise ValueError("[Error]: Given ideal is not an associated prime ideal.")
        if isinstance(an_ideal_or_face,tuple):
            list_associated_faces = list(self.__dict_max_overlap_classes.keys())
            if an_ideal_or_face in list_associated_faces:
                ovl_classes = self.overlap_classes()
                return len(ovl_classes[an_ideal_or_face])
            raise ValueError("[Error]: A prime ideal corresponding to the given face is not an associated prime ideal.")
        raise ValueError("[Error]: Given parameter is not either an ideal or a face")
    def _irreducible_component(self, face,ov_class):
        r"""
        This is a part of the method ``self.irreducible_decomposition()``.
        Given a face and the maximal overlap class, return the irreducible ideal having the maximal overlap class as the unique
        maximal overlap class.

        Notes that .maximal_overlap_classes() cannot be used, since the ideal itself is not defined properly
        for the irreducible components. 
        
        """
        zero_ideal = MonomialIdeal(np.array([], dtype='int64'), self.__ambient_monoid)
        if self.is_irreducible() == True:
            return [self]
        # For each max overlap class,
        # Collect all starting monomial of pairs in the max_ov_class
        testing_monomials = [pair.monomial() for pair in ov_class]
        # Find its minimal solution over the generators.
        # The objective is to find ``level`` of monomials, i.e., how many summation is needed to get the monomial
        # via generators of the affine monoid.
        # Definition of level of a monomial; given a generators (a_1,...,a_n), a level of monomial
        # b is max_{(c_1,...,c_n) s.t. b = \sum_{i}c_{i}a_{i}}\sum_{i}c_{i}.
        minsol = [self.__ambient_monoid.is_element(monomial) for monomial in testing_monomials]
        
        final_pairs = []
        for count, mat in enumerate(minsol):
            pair_with_zeroideal = properpair.ProperPair(ov_class[count].monomial(), face, zero_ideal)
            if mat != matrix(ZZ,0):
                level_list = list(np.sum(np.array(mat),axis=1))
                max_level = max(level_list)
                # Now get all elements with the same level.
                candid_monomials=[]
                zero_pair = properpair.ProperPair(self.__gens[:,[0]]*0, self.__ambient_monoid.face_lattice().top(), zero_ideal)
                for idx in range(max_level+2):
                    candid_monomials = candid_monomials + _stdpairs._tracing_of_overlap_class([zero_pair], self.__ambient_monoid.face_lattice().top(), idx, [()])
                # Generate standard pairs using these;
                candid_pairs = [properpair.ProperPair(item, face, zero_ideal) for item in candid_monomials]
                checker=[]
                for candid_pair in candid_pairs:
                    # If candid pair divides the original one
                    if np.array(properpair.div_pairs(candid_pair, pair_with_zeroideal)).size>0:
                        checker.append("Keep")
                    # If original pair divides the candidate,
                    else:
                        checker.append("Del")
                # Now keep the pairs smaller than maximal.
                candid_pairs=[candid_pairs[jdx] for jdx,jtem in enumerate(checker) if jtem == "Keep"]
                final_pairs = final_pairs+_stdpairs._unique_pairs(candid_pairs+ [pair_with_zeroideal])
            else:
                continue
        final_pairs = _stdpairs._unique_pairs(final_pairs)
        new_cover = _stdpairs._max_standard_pairs({face:final_pairs}, zero_ideal)            
        return _stdpairs._stdcover_to_ideal(new_cover, self.__ambient_monoid)

    def irreducible_decomposition(self):
        r"""
        returns a ``list`` consisting of irreducible ideals such that their intersection is equal to ``self``.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A ``list`` object consisting of ``MonomialIdeal`` objects which are irreducible and their intersection is the same as ``self``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: I.irreducible_decomposition()                                                                                                             
            [An ideal whose generating set is 
             [[1]
              [0]],
             An ideal whose generating set is 
             [[2]
              [2]]]
            sage: I.irreducible_decomposition()[0].intersect(I.irreducible_decomposition()[1]) == I                           
            True

        """
        if self.__is_irr_decom_prime_calculated ==True:
            return self.__list_irreducible_decom_ideals
        if self.is_irreducible() == True:
            self.__list_irreducible_decom_ideals = [self]
            self.__is_irr_decom_prime_calculated =True
            return self.__list_irreducible_decom_ideals
        max_overlaps = self.maximal_overlap_classes()
        ideals=[]
        for face, ov_classes in max_overlaps.items():
            for ov_class in ov_classes:
                ideals.append(self._irreducible_component(face,ov_class))
        self.__list_irreducible_decom_ideals= ideals
        self.__is_irr_decom_prime_calculated =True
        return self.__list_irreducible_decom_ideals
    def intersect(self,other):
        r"""
        Given a monomial ideal ``other``, returns the intesection of ``self`` and ``other``.

        OUTPUT:

        - A ``MonomialIdeal`` object representing the intersection of ``self`` and ``other``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: I.irreducible_decomposition()                                                                                                             
            [An ideal whose generating set is 
             [[1]
              [0]],
             An ideal whose generating set is 
             [[2]
              [2]]]
            sage: I.irreducible_decomposition()[0].intersect(I.irreducible_decomposition()[1])                                                              
            An ideal whose generating set is 
            [[3]
             [2]]
            sage: I.irreducible_decomposition()[0].intersect(I.irreducible_decomposition()[1])==I                                                           
            True
            sage: I.irreducible_decomposition()[1].intersect(I.irreducible_decomposition()[0])==I                                                           
            True
        """
        if not isinstance(other, MonomialIdeal):
            raise ValueError("[Error] The parameter is not an ideal")
        if self.__ambient_monoid != other.ambient_monoid():
            raise ValueError("[Error] Two ideal are from distinct AffineMonoid objects")
        zero_ideal = MonomialIdeal(np.array([]).astype('int64'), self.__ambient_monoid)
        cover = self.standard_cover()
        o_cover = other.standard_cover()
        keys = list(set(list(cover.keys()) +list(o_cover.keys())))
        new_cover={}
        for key in keys:
            if (key in cover.keys()) and (key in o_cover.keys()):
                value = [ properpair.ProperPair(pair.monomial(), pair.face(), zero_ideal) for pair in cover[key]]
                o_value = [ properpair.ProperPair(pair.monomial(), pair.face(), zero_ideal) for pair in o_cover[key]]
                new_cover[key] = _stdpairs._unique_pairs(value+o_value)
            elif (key in cover.keys()) and (key not in o_cover.keys()):
                new_cover[key] = [ properpair.ProperPair(pair.monomial(), pair.face(), zero_ideal) for pair in cover[key]]
            elif (key not in cover.keys()) and (key in o_cover.keys()):
                new_cover[key] = [ properpair.ProperPair(pair.monomial(), pair.face(), zero_ideal) for pair in o_cover[key]]
        return _stdpairs._stdcover_to_ideal(new_cover,self.__ambient_monoid)
    def save(self, path_of_file):
        r"""
        saves the given ``MonomialIdeal`` object as sobj file. All previous calculations using ``self.standard_coveer()`` is also saved. 
        See `Object Persistence <https://doc.sagemath.org/html/en/reference/misc/sage/misc/persist.html>`_ for detail.

        INPUT:

        - ``path_of_file`` -- A ``string`` object denoting the path which the object ``self`` will be saved as a binary file.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: from pathlib import Path
            sage: A = matrix(ZZ,[[0,1,1,0],[0,0,1,1],[1,1,1,1]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]]),Q)
            sage: I.associated_primes()
            {(0,
              3): An ideal whose generating set is 
             [[1 1]
              [0 1]
              [1 1]]}
            sage: I = loads(dumps(I))
            sage: I.associated_primes()
            {(0,
              3): An ideal whose generating set is 
             [[1 1]
              [0 1]
              [1 1]]}
            sage: #The object remember pre-calculated results so that it does not calculate again.
        """
        # If path_of_file starts with ~, change it as a Home directory.
        if not isinstance(path_of_file,str):
            raise ValueError("[Error]: The given instance is not a valid path")
        if path_of_file[0] == '~':
            path_of_file = str(Path.home())+path_of_file[1:]
        sobj_save(self, path_of_file)
    def radical(self):
        r"""
        returns the radical of ``self`` as a ``MonomialIdeal`` object.
        Notes that this method executes``self.standard_cover()`` if it was not executed previously.

        OUTPUT:

        - A ``MonomialIdeal`` object which is radical of the given ideal ``self``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[1,2],[0,2]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[5],[4]]),Q)
            sage: I.radical()
            An ideal whose generating set is 
            [[3]
             [2]]

        """
        if self.__is_radical_ideal_calculated == True:
            return self.__radical_ideal
        if self.is_radical() == True:
            self.__is_radical_ideal_calculated = True
            self.__radical_ideal = self
            return self.__radical_ideal
        sub_cpx = [];
        stdpair_for_radical={}
        for face, pair_list in self.__dict_standard_pairs.items():
            for pair in pair_list:
                if np.any(pair.monomial()) == False:
                     sub_cpx.append(face)
                     stdpair_for_radical[face]=[pair]
        
        gens_in_sub_cpx = [];
        for tup in sub_cpx:
            for ind in tup:
                gens_in_sub_cpx.append(ind)
        gens_in_sub_cpx = list(set(gens_in_sub_cpx))
        # Now set the attribute saving generators
        gens_of_radical =[];
        # First of all, put all rays outside of the subcomplex.
        for ind in range((self.__ambient_monoid.gens()).shape[1]):
            if ind not in gens_in_sub_cpx:
                gens_of_radical.append((ind,))
        # Now, put all sums of generators outside of the subcomplex
        comb_of_gens_in_sub_cpx = Combinations(gens_in_sub_cpx)
        for comb in comb_of_gens_in_sub_cpx:
            parity_tup = False
            for tup in sub_cpx:
                if set(comb).issubset(set(tup)):
                    parity_tup = True
            if parity_tup == False:
                gens_of_radical.append(comb)
        #Lastly, return the monomial ideal with standard pairs.
        gen_set=[]
        for gen_list in gens_of_radical:
            # Do column sum
            temp = np.sum((self.__ambient_monoid.gens())[:,gen_list], axis=1)
            gen_set.append(np.reshape(temp, (temp.shape[0],1)))
        returning_ideal = MonomialIdeal(np.concatenate(gen_set,axis=1), self.__ambient_monoid )
        returning_ideal.is_std_cover_calculated = True;
        returning_ideal.__dict_standard_pairs = stdpair_for_radical
        self.__is_radical_ideal_calculated = True
        self.__radical_ideal = returning_ideal
        return self.__radical_ideal
    def save_txt(self):
        r"""
        returns a ``string`` object containing information about the given monomial ideal and its properties calculated previously. One can recover it using ``txt_to_monomialideal()`` method.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: A = matrix(ZZ,[[1,2],[0,2]])
            sage: Q = AffineMonoid(A)
            sage: I = MonomialIdeal(matrix(ZZ,[[5],[4]]),Q)
            sage: I.standard_cover()[(1,)]
            [([[0], [0]]^T,[[2], [2]])]
            sage: I.standard_cover()[(0,)]
            [([[0], [0]]^T,[[1], [0]]), ([[2], [2]]^T,[[1], [0]])]
            sage: sorted(I.standard_cover().keys(),key=str)
            [(0,), (1,)]
            sage: I.save_txt()                                                                                                                              
            'I\nQ\n1,2|0,2\nis_empty_ideal\n0\ngens\n5|4\n__is_std_cover_calculated\n1\n{"(1,)": ["0|0&(1,)"], "(0,)": ["0|0&(0,)", "2|2&(0,)"]}\n__is_overlap_calculated\n0\n__is_max_overlap_calculated\n0\n__is_ass_prime_calculated\n0\n__is_irr_decom_prime_calculated\n0\n'
        """
        text_info = "I\n"
        # Write the ambient monoid
        text_info = text_info+"Q\n"+_string_interface._np2d_to_string(self.__ambient_monoid.gens())+"\n"
        # Now write Ideal
        text_info = text_info+"is_empty_ideal\n"+str(int(self.is_empty()))+"\n"
        if self.is_empty() == False:
            #Write genset
            text_info = text_info+"gens\n"+_string_interface._np2d_to_string(self.__gens)+"\n"
            #Write whether it has std cover or not.
            text_info = text_info+"__is_std_cover_calculated\n"+str(int(self.__is_std_cover_calculated))+"\n"
            if self.__is_std_cover_calculated == True:
                text_info = text_info+_string_interface._json_dump_cover(self.__dict_standard_pairs)+"\n"
            text_info = text_info+'__is_overlap_calculated\n'+str(int(self.__is_overlap_calculated))+"\n"
            if self.__is_overlap_calculated == True:
                text_info= text_info+_string_interface._json_dump_overlap_classes(self.__dict_overlap_classes)+"\n"
            text_info = text_info+'__is_max_overlap_calculated\n'+str(int(self.__is_max_overlap_calculated))+"\n"
            if self.__is_max_overlap_calculated == True:
                text_info = text_info+_string_interface._json_dump_overlap_classes(self.__dict_max_overlap_classes)+"\n"
            text_info = text_info+'__is_ass_prime_calculated\n'+str(int(self.__is_ass_prime_calculated))+"\n"
            if self.__is_ass_prime_calculated == True:
                str_ass_primes = {}
                for key, value in self.__dict_associated_prime_ideals.items():
                    str_ass_primes[str(key)]=value.save_txt()
                text_info = text_info+json.dumps(str_ass_primes)+"\n"
            text_info = text_info+'__is_irr_decom_prime_calculated\n'+str(int(self.__is_irr_decom_prime_calculated))+"\n"
            if self.__is_irr_decom_prime_calculated == True:
                str_irr_decom = [an_ideal.save_txt() for an_ideal in self.__list_irreducible_decom_ideals]
                text_info = text_info+json.dumps(str_irr_decom)
        return text_info
    def _manually_set_attributes(self, str_option, item):
        r"""
        Used for ``txt_monomialideal()`` method to avoid repeated calculation.
        Do not use it until you are sure that your computational result is True.
        """
        if str_option == '__dict_standard_pairs':
            self.__dict_standard_pairs = item
            self.__is_std_cover_calculated = True
        if str_option == '__dict_overlap_classes':
            self.__dict_overlap_classes = item
            self.__is_overlap_calculated = True
        if str_option == '__dict_max_overlap_classes': 
            self.__dict_max_overlap_classes = item
            self.__is_max_overlap_calculated = True
        if str_option == '__list_irreducible_decom_ideals':
            self.__list_irreducible_decom_ideals = item
            self.__is_irr_decom_prime_calculated = True
        if str_option == '__is_ass_prime_calculated':
            self.__dict_associated_prime_ideals = item
            self.__is_ass_prime_calculated = True
    def _is_std_cover_calculated(self):
        r"""
        Used for ``_stdpairs`` module to check some calculation.
        """
        return self.__is_std_cover_calculated

    def __str__(self):
        return "An ideal whose generating set is \n"+np.array2string(self.__gens)+""
    def __repr__(self):
        return str(self)
    def __add__(self, other):
        r"""
        Given a monomial ideal ``other``, returns the addition of ``self`` and ``other``, which is a monomial ideal generated by generators in both given ideals.

        OUTPUT:

        - A ``MonomialIdeal`` object representing a monomial ideal which is the addition of ``self`` and ``other``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: J=MonomialIdeal(matrix(ZZ,[[4,7],[2,0]]),Q)
            sage: I+J                                                                                                                                       
            An ideal whose generating set is 
            [[3 7]
             [2 0]]
        """
        if self.__ambient_monoid == other.ambient_monoid():
            # Return a monomial ideal generated by generators of both ideals.
            if self.is_empty():
                return other
            if other.is_empty():
                return self
            return MonomialIdeal(np.concatenate((self.__gens.T,(other.gens()).T)).T, self.__ambient_monoid )
        else:
            raise ValueError("[ERROR]: Ambient monoids of two ideals are not the same.")
    def __eq__(self, other):
        r""" 
        returns ``True`` iff two ``MonomialIdeal`` objects are equal, i.e., having the same generating matrices and the same ambient monoid.

        
        EXAMPLE::
            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: J=MonomialIdeal(matrix(ZZ,[[3,7],[2,2]]),Q)
            sage: I == J
            True
        
        TESTS::
            
            sage: from stdpairs import AffineMonoid
            sage: A = matrix(ZZ,[[0,1,1,0],[0,0,1,1],[1,1,1,1]])
            sage: Q = AffineMonoid(A) 
            sage: I = MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]]),Q)
            sage: G = SymmetricGroup(matrix(I.gens()).ncols())
            sage: for permutation in G: 
            ....:     if (I== MonomialIdeal(matrix(ZZ,[[2,2,2],[0,1,2],[2,2,2]])*permutation,Q)) == False: 
            ....:         raise SyntaxError("[Error]: __eq__ does not work properly.")
                                                                                       
        """
        if not isinstance(other, type(self)): return NotImplemented
        if self.__gens.shape != other.gens().shape:
            return False
        return _zsolve_interface._check_swap_column_equivalence(self.__gens, other.gens())

    def __mul__(self,other):
        r"""
        Given a monomial ideal ``other``, returns the multiplication of ``self`` and ``other``, which is a monomial ideal generated by sum of generators one from the ``self`` and the other from ``other``.

        OUTPUT:

        - A ``MonomialIdeal`` object representing a monomial ideal which is the addition of ``self`` and ``other``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, MonomialIdeal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: I=MonomialIdeal(matrix(ZZ,[[3],[2]]),Q)
            sage: J=MonomialIdeal(matrix(ZZ,[[4,7],[2,0]]),Q)
            sage: I*J                                                                                                                                       
            An ideal whose generating set is 
            [[ 7 10]
             [ 4  2]]
        """
        if (self.is_empty()):
            return self
        if (other.is_empty()):
            return other
        if self.__ambient_monoid == other.ambient_monoid():
            # Return a monomial ideal generated by addition of generators of both ideals.
            newgens=[]
            for indone in range(self.__gens.shape[1]):
                for indtwo in range((other.gens()).shape[1]):
                    newgens.append(self.__gens[:,indone] + (other.gens())[:,indtwo])
            newgens = np.array(newgens).astype('int64').T
            return MonomialIdeal(newgens, self.__ambient_monoid )


def prime_ideal(face, affine_monoid):
    r"""
        Given a ``tuple`` object ``face``  representing face of ``affine_monoid``, return  monomial ideal ``other``, return the prime monomial ideal corresponding to the face.

        OUTPUT:

        - A ``MonomialIdeal`` object representing a prime monomial ideal corresponding to the ``face``.

        EXAMPLE::

            sage: from stdpairs import AffineMonoid, prime_ideal
            sage: Q=AffineMonoid(matrix(ZZ,[[1,2],[0,2]]))
            sage: prime_ideal((0,),Q)                                                                                                                       
            An ideal whose generating set is 
            [[2]
             [2]]
            sage: prime_ideal((1,),Q)                                                                                                                       
            An ideal whose generating set is 
            [[1]
             [0]]
        """
    if not isinstance(affine_monoid, affinemonoid.AffineMonoid):
        raise ValueError("[Error]:The first parameter is not an affinemonoid.AffineMonoid type.")
    if not isinstance(face,tuple):
        raise ValueError("[Error]:The second instance is not a tuple type.")
    if face in affine_monoid.face_lattice():
        if face != (-1,):
            complement_index=[]
            for ind in range((affine_monoid.gens()).shape[1]):
                if ind not in face:
                    complement_index.append(ind)
            complement_index = tuple(complement_index)
            return MonomialIdeal((affine_monoid.gens())[:,complement_index], affine_monoid)
        else:
            raise ValueError("[Error]: (-1,) does not corresponds to a prime ideal.")
    else:
        raise ValueError("[Error]:Instance is not a face of the affine monoid")